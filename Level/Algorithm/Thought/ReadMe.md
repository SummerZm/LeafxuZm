## 算法思维
> 引子：我们用自然语言描述问题需求，想出解决方法，用编程语言让计算机干活。
- 如何将量化模型转化为相应编程语言的？
- 我们应该在量化前构思解决问题的步骤，还是在量化之后构思解决问题的步骤？- 这关系到我们如何正确看待/使用算法思维？
- 算法是建立解空间并进行有效的枚举和高效的重复。

### 自然语言问题需求可量化基础
> 有些问题交给人去解决，有些问题交给计算机去解决 
- 人的主/客观

> 广义上的边界
- 自然语言的表达力
- 数学语言的表达力
- 计算机体系模型的表达力

> 狭义上的边界 (引入时空限制)
- 计算的边界：可计算问题/不可计算问题。离散数学和连续数学的交界点。

### 自然语言量化到数学模型: 【审题找可行方法】
- 解空间的理解

### 数学模型量化到编程语言(符合计算机的体系结构) 【写代码】
- 编程语言的范式：分支，循环，顺序.
- 编程语言的结构：堆栈.
- 注重语法基础和题解模版.(算法的表达形式)
- 自然语言问题需求转编程语言工作需求：
	1. 存储需求: 数据结构 - 性能+数据被赋予某些特性【栈的匹配特性/集合去重特性】
	2. 排列需求: 排列依据 - 排列之后的数据被赋予某些特性.
	3. 去重需求：可通过集合实现.
	4. 查找需求：查找公式 - 树的判断公式.
	5. 公式分析: 
		数据生成: 子函数调用
		数据筛选: 数学公式 / IF分支
		数据存储: 栈 / 返回值 / 堆
- 从输入输出的角度
	1. 输出结果是怎么样的数据结构？
	2. 有哪些数据结构输入？
	3. 中间状态如何存储？
	4. 中间能对数据进行怎么样的操作？这些数学操作蕴含的自然语义
- 从数据结构的角度
	1. 数据结构的是实现本身就是: 对自然语言需求实现。
		```
		# a. 自然语言描述了堆的接口和性能需求。
		# b. 代码提供了接口，数学公式指导了实现。
		```
	2. 不同的数据结构都围绕着增/删/改/查提供接口。
	3. 数据结构自身就符合自然需求。这意味着我们在具体的代码实现中便捷使用他们。
	4. 数据结构解决了自然需求中的‘存储’。
	5. 有些问题在数据结构建完时，数据结构的特性就已经把答案给出来了。
- 从代码计算机语言的角度观察算法思想的性质/模版
	1. 贪心算法：求最值
	2. 分治算法：递归前期
	3. 动态规划: 动态规划方程式
	4. 回溯算法：递归末期
	5. 分支界限法：限制条件
	6. 线性规划网络流：


### 算法起源于自然语言的问题需求，解决实现于数学语言基础，结束/输出/受限于计算机体系结构。

### 算法思路流程
> **目标组成：解决自然语言需求，计算机语言输出，性能可行**
- **算法思路流程总论**
	1. 我们需要一些工具/角度去完成目标
		```sh
		#  数据量化角度：支撑资自然语言需求的分析，进入数学语言模型。
		#  解空间和策略：是链接自然语言需求和计算机语言输出的桥梁，同时保证性能。
		#  计算体系结构：数据流演化的载体，确保计算机语言输出。
		```
	2. 看待目标的角度
		```sh
		# 语言角度： 自然语言需求 -> 数学语言模型 -> 计算机语言代码
		# 数据角度： 数据量化 -> 数据模型 -> 数据流控/载体呈现
		# 理论角度： 量化方法 —> 解空间和策略 -> 计算机体系结构		
		#
		# 不同角度同阶段的依赖关系：
		# 第一阶段：自然语言需求【主谓宾分析】 -> 量化方法【数组/坐标/n元组】-> 数据量化【常识性约束条件】
		#	自然语言需求：自然语言需求如何量化成数学语言？
		#	1. 确定输入/处理/输出 - 哪些约束可以量化? - 哪些是干扰?
		#	2. 处理是指：增，删，改，查。
		#	3. 数据结构可以赋予数学特性，有些问题在建好模时就已经解决了。例如：十字链接表/邻接矩阵。
		#		改：修改数组的数据排列 【移动0】
		#		查：符合条件的最大值 【上楼梯路径/最多容器/三数之和】
		# 		删：
		#  		增：
		#
		# 第二阶段：数学语言模型【找寻现有数学模型】 -> 数据模型【正反建立数学模型】-> 解空间和策略【开始进入计算机语言】
		#	数学语言模型：如何建立数学语言模型解决问题？
		#	
		#	此阶段的目的是建立解空间；明确了解空间我们再考虑如何枚举。介于中间的阶级很麻烦的同时也具有很多工具。
		#  【建立解空间的工具集】
		#	来自第一阶段的工具：自然与数学问题：
		#		合理的量化方法能为解空间赋能 ：数组/坐标/n元组 
		#	   	明确的问题类型选择合适的存储类型
		#	来自第二阶段的工具：找寻现有数学模型/赋予数据特性-排序		
		#	来自第三阶段的工具：数学与计算问题：尝试从计算机角度解决可计算的数学问题 ：贪心/动规/回溯/分支/线规	
		#	
		#  【实现解空间的工具集：解空间策略与代码实现】
		#	 1. 解空间分治/回溯 -> 递归结构
		# 	 2. 解空间初始化 -> 顺序语句
		#	 3. 解空间探索 -> 剪枝：约束条件：IF语句
		#	 4. 解空间演化/枚举/最优子结构 -> 迭代/递归：循环语句
		#
		#	话题：为什么贪心/动规/回溯/分支/线规属于计算机角度？
		#	1. 它们的本质是：枚举和重复
		#	2. 它们的实现是：分支/循环/顺序/递归
		#	3. 算法思维可以和编程语言的分支/循环/顺序/递归有良好的对应
		#	4. 算法思想是探索解空间的手段策略。
		#		a. 计算机语言：递归
		#		b. 解空间生成/演化/探索策略：动态规划
		#		c. 数学归纳：数学公式
		#		d. 自然语言需求。
		#		
		# 第三阶段：计算机体系结构【大方向：输入-存储-处理-输出】 -> 数据流控/载体呈现【分支/循环/顺序/递归】-> 计算机语言代码【基本语法】
		#	计算机语言编写: 如何将数学语言模型翻译成计算机语言？
		#	
		#	里子：计算机体系结构：【冯诺依曼/哈佛体系结构】： 输入 - 处理【运算器/存储器/逻辑控制单元】- 输出
        #	面子：编程语言基本结构：顺序/分支/循环： 基础源自于逻辑控制单元
        #	特性：递归/堆栈特性
        #	本质：重复/枚举 
		#
		#	名词解释：
		#	载体呈现：例如：在性能要求较高：数组内部自排序，不能申请新内存。就需要在数学模型允许的情况下，对数组载体进行调整利用。
		#	
		# 总结：
		#	1. 我们从自然语言需求分析建立解空间
		#	2. 这个解空间可以是收敛的，我们能通过动态规划/数学公式去描述，去迭代演化出就答案。
		#	3. 这个解空间可以是发散的，但通过一些约束条件，我们能在可计算范围内找到答案。
		#	4. 甚至，这解空间是这题干已经给出需要我们自己去解析自然语言的需求，找出范围合适的解空间和答案。
		```

- **算法思维**
	1. 贪心算法：原问题整体最优可以通过一系列局部子问题的最优解决。一般没有回溯
		```sh
		# 贪心选择：要自己确定一种选择策略。实际上就是确定最优子结构。
		# 最优子结构：原问题的最优解包含了子问题的最优解。
		# 总结：这个解往往是个集合。
		```
	2. 分治算法
		```sh
		# 原问题可以分解为若干个规模较小的相同子问题。
		# 子问题互相独立。
		# 子问题的解可以合并为原问题的解。
		# 公式：
		#	1. 把一个大的复杂问题分为a(a>=1)个形式相同的子问题;
		#	2. 这些子问题的规模为 n/b； 
		#	3. 分解或者合并的复杂度为 f(n);
		#
		#	T(n) =  O(1)   		  , n=1
		#		 	aT(n/b) + f(n), n>1
		#
		# 如何快速计算分治算法的时间复杂度
		#	1. 每层成本的趋势：递增/递减/不变
		#	2. 如何计算每层成本？
		#	3. 如何看出每层成本的变化趋势？
		#	
		# 总结：这个解是个合成值。
		```
	3. 动态规划
		```sh
		# 动态规划：自底向上，先求解最小的子问题，把结果记在表格中，求解较大问题时可在表格中查询结果。
		# 最优子结构：原问题的最优解包含了子问题的最优解。
		# 子问题重叠：子问题堆叠是动态规划高效的原因。
		#
		# 如何判定最优子结构？
		# 1. 已经知道某种最优选择。
		# 2. 之后会产生哪些子问题。
		# 3. 证明原问题的最优解包含其子问题的最优解。
		# 
		# 如何得到最优解递归式？ 
		# 1. 分析原问题的最优解和子问题最优解的关系。子问题如何拼接成原问题。【根据具体场景】
		# 2. 考察有多少种选择。
		# 3，得到最优解递归式。
		```
	4. 回溯算法【深度搜索算法】
		```sh
		# a. 定义解空间
		#	 解的组织形式都规范为一个n元组
		#
		# b. 确定解空间的组织结构
		#	 通常是m叉树
		#
		# c. 搜索解空间
		#    可行解：约束函数	 
		# 	 最优解：界限函数
		#
		# 提炼：显约束控制空间大小；剪枝函数决定剪枝效率。 
		# 呈现：先序遍历，深度搜索。
		```
	5. 分支界限法【广度搜索算法】
		```sh
		# a. 队列式分支界限法
		# b. 优先队列式分支界限法
		# 
		# 例子：寻路算法。
		```
	6. 线性规划网络流
		```sh
		#
		#
		#
		#  
		```


























