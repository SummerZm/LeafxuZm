## TCP/IP协议族

### TCP/IP协议族体系结构以及主要是协议
- 数据链路层【帧】：屏蔽不同的物理介质特性。 ARP / RARP 
- 网络层【报】：数据包的选路和转发。 ICMP / IP
- 传输层【段】：TCP/UDP。
- 应用层 ：DNS， HTTP。

### 网络数据报文格式
- 以太帧： 6 目标物理addr  + 6 源物理地址 + 类型 + 46～1500  + CRC
- IP数据报： 20字节以上 （TTL + 质量服务 + MTU）

### 网络层：IP层可以做的事：识别主机
- 报文头长度： 20 字节
- 16位标识：被分片的数据报使用同一个标识。
- 8位TOS字段：最小延时(ssh/telnet)，最大吞吐量(ftp)，最高可靠性，最小费用。
- IP分片设置：
    1. 设置DF禁止分片，当报文超过MTU时，会被丢弃并返回 ICMP差错报文。
    2. MF被分片数据报要设置。 
- IP数据可选信息：指定路由路径，记录路由，时间戳。
- TTL: 数据报生存期。
- CRC 校验的是IP报文头。

### 传输层：
- TCP模块：
    1. 可靠传输
    2. TCP报文头结构：
        ```sh
        # 16位：端口号 
        # 32位序号： 
        # 32位确认号：
        # 16位窗口大小：告诉对方本端TCP接收缓冲区还能容纳多少字节数据
        # 16位校验和：
        # 16位紧急指针：
        # 6种标志位：URG[紧急] / ACK[确认] / PSH[提示接收段应立即读走信息] / RST[重联] / SYN / FIN 标志
        # 
        # tcp选项： 
        #  kind = 1: 空操作。
        #  kind = 2: 最大报文。
        #  kind = 3: 窗口扩大因子。
        #  kind = 4: 选择性确认。
        #  kind = 5: SACK实际工作选项。
        ```

    3. TCP状态机场景：
        ```sh
        # a. 同时开链接。
        # b. 半关闭状态检查。 read() 返回 0
        # c. 链接超时：/proc/sys/net/ipv4/tcp_syn_retries
        # d. TIME_WAIT状态： 
        #      1. 彻底终止TCP链接。客户端最后一个是确认报文丢失，超时，客户端会发送重置报文给服务端。
        #      2. 让应用程序很好的分离。 避免端口复用。
        #      3. 2MSL是为了等待链路上残留报文消失。
        #
        # e. 异常终止链接：SO_LINGER
        # f. 处理半打开的链接：
        #      1. 原因一端突然被拔掉网线。
        #      2. 再次链接时会收到对端的复位报文。
        ```
    
    4. TCP数据流：
        ```sh
        # A. 交互数据流: IP TOS -> 容易造成阻塞 -> nagle算法【减少网络零碎包】
        # B. 成块数据流：调整通告，窗口大小
        # C. 带外数据流：带外标志 / 紧急指针 / 有socket编程接口可以获取带外数据
        ```

    5. TCP数据传输
        ```sh
        # 1. 超时重传
        # 2. 拥塞控制
        # 3. 快速重传和快速恢复
        ```

- UDP模块：
    1. 会丢包

### 高性能服务器程序框架
- **服务器模型**
1. C/S模型
2. P2P模型

- **IO模型**
1. 阻塞I/O：程序阻塞于读写函数。
2. I/O复用：程序阻塞于I/O复用系统调用。
3. SIGIO信号：信号触发读写就绪事件，用户程序执行读写操作，程序没有阻塞阶段。
4. 异步I/O：内核执行读写操作并触发读写完成事件，程序没有阻塞阶段。

- **高效事件处理模式**
1. 【同步IO模型】Reactor模式：分发IO事件。
2. 【异步IO模型】Proactor模式：处理IO读写事件，发送就绪事件通知。

- **高效的并发模式**
> **IO处理单元和逻辑单元之间协完成任务方法**
1. 问题：IO模型和并发模型的同/异步之间区别
    ```sh
    # IO模型：通知什么样的事件类型，读写操作由谁完成？
    # 并发模型：
    #   a. 同步：完全按照代码排序执行.
    #   b. 异步：执行需要由系统事件来驱动.
    ```

2. 半同步/半异步模式
    ```sh
    # 简介：
    # a. 同步线程：处理客户逻辑.
    # b. 异步线程：将请求封装成对象并插入请求队列.
    #
    # 缺点：
    # a. 工作队列的上锁问题.
    # b. 工作队列不够用.
    # c. 一个线程只能处理一个链接
    # 
    # 高效的半反应堆模式
    ```

3. 领导者/追随者模式

4. 高性能服务器
    ```sh
    # a. 以空间换时间
    #   1. 线程池：
    #   2. 内存池：
    #   3. 连接池：
    #   4. 池的管理算法要义
    # b. 数据复制：
    # c. 上下文切换和锁：
    #   1. 消费者线程
    ```




